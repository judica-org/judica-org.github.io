<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@200;500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;600&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/style.css><script>const storage=window.localStorage,get_darkmode=()=>{const e=storage.getItem("darkmode");return e==null||e==="true"},set_darkmode=()=>{get_darkmode()?(document.body.classList.remove("lightmode"),document.body.classList.add("darkmode")):(document.body.classList.remove("darkmode"),document.body.classList.add("lightmode"))};function applyBackgroundTheme(e){var n="body { background: "+e+"; }",s=document.head||document.getElementsByTagName("head")[0],t=document.createElement("style");return s.appendChild(t),t.type="text/css",t.styleSheet?t.styleSheet.cssText=n:t.appendChild(document.createTextNode(n)),t}const style=applyBackgroundTheme(get_darkmode()?"black":"white");document.addEventListener("DOMContentLoaded",()=>{set_darkmode(),style.parentElement.removeChild(style);const e=document.getElementsByClassName("darkmode-switch")[0];e.onclick=e=>{storage.setItem("darkmode",!get_darkmode()),get_darkmode(),set_darkmode()}})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-175497336-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Congestion Control"><meta property="og:description" content="This post is syndicated from rubin.io.
Welcome to day 12 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
Congestion is an ugly word, eh? When I hear it my fake synthesia triggers green slime feeling, being stuck in traffic with broken AC, and ~the bread line~ waiting for your order at a crowded restaurant when you&rsquo;re super starving."><meta property="og:type" content="article"><meta property="og:url" content="https://judica.org/blog/advent-12/"><meta property="og:image" content="https://judica.org/img/og-img.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-09T00:00:00+00:00"><meta property="og:site_name" content="judica.org -- restore the balance"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://judica.org/img/og-img.png"><meta name=twitter:title content="Congestion Control"><meta name=twitter:description content="This post is syndicated from rubin.io.
Welcome to day 12 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
Congestion is an ugly word, eh? When I hear it my fake synthesia triggers green slime feeling, being stuck in traffic with broken AC, and ~the bread line~ waiting for your order at a crowded restaurant when you&rsquo;re super starving."></head><body><header class=nav><ul><li class=float-left><a href=/>judica.</a></li></ul><ul><li><a href=/about/>about.</a></li><li><a href=/software/>software.</a></li><li><a href=/blog/>blog.</a></li><li><a href=/join/>join.</a></li></ul></header><div class=main2><h1>Congestion Control</h1><div><h2 class=nobottom>Day 12: Rubin's Bitcoin Advent Calendar</h2></div><small>on December 9, 2021</small><hr></div><div class=main2><div></div><div class=blogtext-inner><p><em>This post is syndicated from <a href=https://rubin.io/advent21>rubin.io</a>.</em></p><p><em>Welcome to day 12 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href=/advent21>here</a> or subscribe at
<a href=https://judica.org/join>judica.org/join</a> to get new posts in your inbox</em></p><p>Congestion is an ugly word, eh? When I hear it my fake synthesia triggers green
slime feeling, being stuck in traffic with broken AC, and ~the bread line~
waiting for your order at a crowded restaurant when you&rsquo;re super starving. All
not good things.</p><p>So Congestion Control sounds pretty sweet right? We can&rsquo;t do anything about the
demand itself, but maybe we can make the experience better. We can take a mucinex,
drive in the HOV lane, and eat the emergency bar you keep in your bag.</p><p>How might this be used in Bitcoin?</p><ol><li>Exchange collects N addresses they need to pay some bitcoin</li><li>Exchange inputs into this contract</li><li>Exchanges gets a single-output transaction, which they broadcast with high fee to get quick confirmation.</li><li>Exchange distributes the redemption paths to all recipients (e.g. via mempool, email, etc).</li><li>Users verify that the funds are &ldquo;locked in&rdquo; with this contract.</li><li>Party</li><li>Over time, when users are willing to pay fees, they CPFP pay for their redemptions (worst case cost \(O(\log N)\))</li></ol><p>Throughout this post, we&rsquo;ll show how to build the above logic in Sapio!</p><h1 id=talk-nerdy-to-me>Talk Nerdy To Me</h1><p>Let&rsquo;s define some core concepts&mldr; Don&rsquo;t worry too much if these are a bit hard
to get, it&rsquo;s just useful context to have or think about.</p><h3 id=latency>Latency</h3><p>Latency is the time from some notion of &ldquo;started&rdquo; to &ldquo;stopped&rdquo;. In Bitcoin you could think of the latency from 0 confirmations on a transaction (in mempool) to 1 confirmation (in a block), which is minimally expected to be 10
minutes for high fee transactions, but could be longer depending on the other transactions.</p><h3 id=fairness>Fairness</h3><p>Fairness is a measure of how &ldquo;equitable&rdquo; a distribution of goods or services is.
For example, suppose I want to divide 10 cookies among 10 children.</p><p>What if 1 child gets two cookies and the other 9 get 8/9ths of a cookie each? Or
what if 1 child gets no cookie and the other 9 get 10/9ths of a cookie each? How
fair is that?</p><p>Mathematicians and computer scientists love to come up with different measures
of fairness to be able to quantatatively compare these scenarios and their
relative fairness.</p><p>In Bitcoin we might think of different types of fairness: how long does your
transaction spend in the mempool? How much fee did you pay?</p><h3 id=throughput--capacity>Throughput & Capacity</h3><p>Let&rsquo;s spend another moment on fairness. Perfectly fair would be:</p><ol><li>All children get 1 cookie</li><li>All children get 1/10th of 1 cookie.</li><li>All children get 0 cookies.</li></ol><p>Clearly only one of these is particularly efficient.</p><p>Thus, we don&rsquo;t just want to measure fairness, we also want to measure the
throughput against the capacity. The capacity is the maximum throughput, and the
the throughput is essentially how many of those cookies get eaten (usually, over
time). Now let&rsquo;s look at our prior scenarios:</p><ol><li>All children get 1 cookie: Perfect Throughput.</li><li>All children get 1/10th of 1 cookie: 1/10th Throughtput/Capacity.</li><li>All children get 0 cookies: 0 Throughput :(</li></ol><p>In this case it seems simple: why not just divide the cookies you big butt!</p><p>Well sometimes it&rsquo;s hard to coordinate the sharing of these resources. For
example, think about if the cookies had to be given out in a buffet. The first
person might just take two cookies, not aware there were other kids who wouldn&rsquo;t
get one!</p><p>This maps well onto the Bitcoin network. A really rich group of people might do
a bunch of relatively high fee transactions that are low importance to them and
inadvertently price out lower fee transactions that are more important to the
sender. It&rsquo;s not malicious, just a consequence of having more money. So even
though Bitcoin can achieve 1MB of base transaction data every 10 minutes, that
capacity might get filled with a couple big consolidation transactions instead
of many transfers.</p><h3 id=burst--over-provisioning>Burst & Over Provisioning</h3><p>One issue that comes up in systems is that users show up randomly. How often
have you been at a restaurant with no line, you order your food, and then as
soon as you sit down the line has ten people in it? Lucky me, you think. <em>I
showed up at the right time!</em>. But then ten minutes later the line is clear.</p><p>Customers show up kind of randomly. And thus we see big bursts of activity.
Typically, in order to accomodate the bursts a restaurant must over-provision
it&rsquo;s staff. They only make money when customers are there, and they need to
serve them quickly. But in between bursts, staff might just be watching grass
grow.</p><p>The same is true for Bitcoin. Transactions show up somewhat unpredictably, so
ideally Bitcoin would have ample space to accomodate any burst (this isn&rsquo;t
true).</p><h3 id=littles-law>Little&rsquo;s Law</h3><p>Little&rsquo;s law is a deceptively simple concept:</p><p>$$L = \lambda \times W$$</p><p>where \(L = \) length of the queue, \(\lambda = \) the arrival rate and
\(W=\) the average time a customer spends in the system.</p><p>What&rsquo;s remarkable about it is that it makes almost no assumptions about the underlying process.</p><p>This can be used to think about, e.g., a mempool.</p><p>Suppose there are 10,000 transactions in the mempool, and based on historical
data we see 57 txns a minute.</p><p>$$ \frac{10,000 \texttt{ minutes}}{57 \texttt{ transactions per minute}} = 175 \texttt{ minutes}$$</p><p>Thus we can infer how long transactions will on average spend waiting in the
mempool, without knowing what the bursts look like! Very cool.</p><h2 id=im-just-showing-off>I&rsquo;m just showing off</h2><p>I didn&rsquo;t really need to make you read that gobbledygook, but I think they are
really useful concepts that anyone who wants to think about the impacts of
congestion & control techniques should keep in mind&mldr; Hopefully you learned
something!</p><h1 id=its-bitcoin-time>It&rsquo;s Bitcoin Time</h1><p>Well, what&rsquo;s going on in Bitcoin land? When we make a transaction there are
multiple different things going on.</p><ol><li>We are spending coins</li><li>We are creating new coins</li></ol><p>Currently, those two steps occur simultaneously. Think of our cookies. Imagine
if we let one kid get cookies at a time, and they also have to get their milk at
the same time. Then we let the next kid go. It&rsquo;s going to take</p><p>$$ T_{milk} + T_{cookies} $$</p><p>To get everyone served. What if instead we said kids could get one and then the
other, in separate lines.</p><p>Now it will take something closer to $$\max(T_{milk}, T_{cookies})$$.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>
Whichever process is longer will dominate the time. (Probably milk).</p><p>Now imagine that getting a cookie takes 1 second per child, and getting a milk
takes 30 seconds. Everyone knows that you can have a cookie and have milk after.
If children take a random amount of time &ndash; let&rsquo;s say on average 3 minutes,
sometimes more, sometimes less &ndash; to eat their cookies, then we can serve 10
kids cookies in 10 seconds, making everyone happy, and then fill up the milks
while everyone is enjoying a cookie. However, if we did the opposite &ndash; got
milks and then got cookies, it would take much longer for all of the kids to
get something and you&rsquo;d see chaos.</p><p>Back to Bitcoin. Spending coins and creating new coins is a bit like milk and
cookies. We can make the spend correspond to distributing the cookies and
setting up the milk line. And the creating of the new coin can be more akin to
filling up milks whenever a kid wants it.</p><p>What this means practically is that by unbundling spending from redeeming we can
serve a much greater number of users that if they were one aggregate product
because we are taking the &ldquo;expensive part&rdquo; and letting it happen later than the
&ldquo;cheap part&rdquo;. And if we do this cleverly, the &ldquo;setting up the milk line&rdquo; in the
splitting of the spend allows all receivers to know they will get their fair share later.</p><p>This makes the system much higher throughput (unlimited confirmations of
transfer), lower latency to confirmation (you an see when a spend will
eventually pay you), but higher latency to coin creation in the best case,
although potentially no different than the average case, and (potentially) worse
overall throughput since we have some waste from coordinating the splitting.</p><p>It also improves costs because we may be willing to pay a higher price for part
one (since it generates the confirmation) than part two.</p><h1 id=can-we-build-it>Can we build it?</h1><p>Let&rsquo;s start with a basic example of congestion control in Sapio.</p><p>First we define a payment as just being an Amount and an Address.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A payment to a specific address
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Payment</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Amount
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// The amount to send in btc
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> amount: <span style=color:#a6e22e>AmountF64</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Address
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// The Address to send to
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> address: <span style=color:#a6e22e>Address</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we&rsquo;ll define a helper called <code>PayThese</code>, which takes a list of contracts
of some kind and pays them after an optional delay in a single transaction.</p><p>You can think of this (back to our kids) as calling a group of kids at a time
(e.g., table 1, then table 2) to get their cookies.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PayThese</span> {
</span></span><span style=display:flex><span>    contracts: Vec<span style=color:#f92672>&lt;</span>(Amount, Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Compilable<span style=color:#f92672>&gt;</span>)<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    fees: <span style=color:#a6e22e>Amount</span>,
</span></span><span style=display:flex><span>    delay: Option<span style=color:#f92672>&lt;</span>AnyRelTimeLock<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> PayThese {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[then]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>expand</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> bld <span style=color:#f92672>=</span> ctx.template();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Add an output for each contract
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (amt, ct) <span style=color:#66d9ef>in</span> self.contracts.iter() {
</span></span><span style=display:flex><span>            bld <span style=color:#f92672>=</span> bld.add_output(<span style=color:#f92672>*</span>amt, ct.as_ref(), None)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// if there is a delay, add it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(delay) <span style=color:#f92672>=</span> self.delay {
</span></span><span style=display:flex><span>            bld <span style=color:#f92672>=</span> bld.set_sequence(<span style=color:#ae81ff>0</span>, delay)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pay some fees
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        bld.add_fees(self.fees)<span style=color:#f92672>?</span>.into()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>total_to_pay</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Amount</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> amt <span style=color:#f92672>=</span> self.fees;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (x, _) <span style=color:#66d9ef>in</span> self.contracts.iter() {
</span></span><span style=display:flex><span>            amt <span style=color:#f92672>+=</span> <span style=color:#f92672>*</span>x;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        amt
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> PayThese {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {then, Self::expand}
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {non updatable}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Lastly, we&rsquo;ll define the logic for congestion control. The basics of what is
happening is we are going to define two transactions: One which pays from A ->
B, and then one which is guaranteed in B&rsquo;s script to pay from B -> {1&mldr;n}. This
splits the confirmation txn from the larger payout txn.</p><p>However, we&rsquo;re going to be a little more clever than that. We&rsquo;ll apply this principle
recursively to create a tree.</p><p>Essentially what we are going to do is to take our 10 kids and then divide them
into groups of 2 (or whatever radix). E.g.: <code>{1,2,3,4,5,6,7,8,9,10}</code> would become
<code>{ {1,2}, {3,4}, {5,6}, {7,8}, {9,10} }</code>. The magic happens when we recursively
apply this idea, like below:</p><pre tabindex=0><code>{1,2,3,4,5,6,7,8,9,10}
{ {1,2}, {3,4}, {5,6}, {7,8}, {9,10} }
{ { {1,2}, {3,4} }, { {5,6}, {7,8} }, {9,10} }
{ { {1,2}, {3,4} }, { { { 5,6}, {7,8} }, {9,10} } }
{ { { {1,2}, {3,4}}, { { {5,6}, {7,8} }, {9,10} } } }
</code></pre><p>The end result of this grouping is a single group! So now we could do a
transaction to pay/give cookies to that one group, and then if we wanted 9 to
get their cookie/sats We&rsquo;d only have to publish:</p><pre tabindex=0><code>level 0 to: Address({ { { {1,2}, {3,4} }, { { {5,6}, {7,8} }, {9,10} } } })
level 1 to: Address({ { {5,6}, {7,8} }, {9,10} } })
level 2 to: Address({9,10})
</code></pre><p>Now let&rsquo;s show that in code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// # Tree Payment Contract
</span></span></span><span style=display:flex><span><span style=color:#e6db74>/// This contract is used to help decongest bitcoin
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#75715e>//// while giving users full confirmation of transfer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(JsonSchema, Serialize, Deserialize)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TreePay</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Payments
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// all of the payments needing to be sent
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> participants: Vec<span style=color:#f92672>&lt;</span>Payment<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Tree Branching Factor
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// the radix of the tree to build.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// Optimal for users should be around 4 or
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// 5 (with CTV, not emulators).
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> radix: <span style=color:#66d9ef>usize</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[serde(with = </span><span style=color:#e6db74>&#34;bitcoin::util::amount::serde::as_sat&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[schemars(with = </span><span style=color:#e6db74>&#34;u64&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Fee Sats (per tx)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// The amount of fees per transaction to allocate.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> fee_sats_per_tx: <span style=color:#a6e22e>bitcoin</span>::util::amount::Amount,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Relative Timelock Backpressure
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// When enabled, exert backpressure by slowing down
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// tree expansion node by node either by time or blocks
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> timelock_backpressure: Option<span style=color:#f92672>&lt;</span>AnyRelTimeLock<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TreePay {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[then]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>expand</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A queue of all the payments to be made initialized with
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// all the input payments
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> queue <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>                .participants
</span></span><span style=display:flex><span>                .iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>payment<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Convert the payments to an internal representation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> amt <span style=color:#f92672>=</span> AmountRange::new();
</span></span><span style=display:flex><span>                    amt.update_range(payment.amount);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> b: Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Compilable<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>                        Box::new(Compiled::from_address(payment.address.clone(),
</span></span><span style=display:flex><span>                        Some(amt)));
</span></span><span style=display:flex><span>                    (payment.amount, b)
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>                .collect::<span style=color:#f92672>&lt;</span>VecDeque<span style=color:#f92672>&lt;</span>(Amount, Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Compilable<span style=color:#f92672>&gt;</span>)<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// take out a group of size `radix` payments
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>let</span> v: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> queue
</span></span><span style=display:flex><span>                    .drain(<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>std::cmp::min(self.radix, queue.len()))
</span></span><span style=display:flex><span>                    .collect();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> queue.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// in this case, there&#39;s no more payments to make so bundle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// them up into a final transaction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> builder <span style=color:#f92672>=</span> ctx.template();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> pay <span style=color:#66d9ef>in</span> v.iter() {
</span></span><span style=display:flex><span>                        builder <span style=color:#f92672>=</span> builder.add_output(pay.<span style=color:#ae81ff>0</span>, pay.<span style=color:#ae81ff>1.</span>as_ref(), None)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(timelock) <span style=color:#f92672>=</span> self.timelock_backpressure {
</span></span><span style=display:flex><span>                        builder <span style=color:#f92672>=</span> builder.set_sequence(<span style=color:#ae81ff>0</span>, timelock)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    builder <span style=color:#f92672>=</span> builder.add_fees(self.fee_sats_per_tx)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> builder.into();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// There are still more, so make this group and add it to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// the back of the queue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>let</span> pay <span style=color:#f92672>=</span> Box::new(PayThese {
</span></span><span style=display:flex><span>                        contracts: <span style=color:#a6e22e>v</span>,
</span></span><span style=display:flex><span>                        fees: <span style=color:#a6e22e>self</span>.fee_sats_per_tx,
</span></span><span style=display:flex><span>                        delay: <span style=color:#a6e22e>self</span>.timelock_backpressure,
</span></span><span style=display:flex><span>                    });
</span></span><span style=display:flex><span>                    queue.push_back((pay.total_to_pay(), pay))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> TreePay {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {then, Self::expand}
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {non updatable}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So now what does that look like when we send to it? Let&rsquo;s do a TreePay with 14 recipients and radix 4:</p><p><img src=/public/img/bitcoin/advent/tree_pay.png alt="sapio studio view of treepay"></p><p>As you can see, the queuing puts some structure into a batched payment! This is
(roughly) the exact same code as above generating these transactions. What this
also means is given an output and a description of the arguments passed to the
contract, anyone can re-generate the expansion transactions and verify that they
can eventually receive their money! These payout proofs can also be delivered in
a pruned form, but that&rsquo;s just a bonus.</p><p>Everyone gets their cookie (confirmation of transfer) immediately, and knows
they can get their milk (spendability) later. A smart wallet could manage your
liquidity over pedning redemptions, so you could passively expand outputs
whenever fees are cheap.</p><p>If you want to read more about the impact of congestion control on the network,
I previously wrote two articles simulating the impact of congestion control on
the network which you can read here:</p><ul><li><a href=https://utxos.org/analysis/bip_simulation/>Congestion Simulation</a></li><li><a href=https://utxos.org/analysis/batching_sim/>Batching Simulation</a></li></ul><p>What&rsquo;s great about this is that not only do we make a big benefit for anyone who
wants to use it, we show in the Batching Simulation that even with the overheads
of a TreePay, the incentive compatible behavior around exchange batching can
actually help us use less block space overall.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Simplifying here &ndash; I know Amdahl&rsquo;s Law&mldr;&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div></div></div><hr><div class=main2><div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//judica-org.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div></div></div><hr><footer style=text-align:center;bottom:0;padding-bottom:10px;width:100%>&copy; Judica, Inc 2022 | contact@judica.org | <a class=darkmode-switch>dark/light theme</a></footer></body></html>