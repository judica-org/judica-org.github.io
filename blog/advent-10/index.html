<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@200;500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;600&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/style.css><script>const storage=window.localStorage,get_darkmode=()=>{const e=storage.getItem("darkmode");return e==null||e==="true"},set_darkmode=()=>{get_darkmode()?(document.body.classList.remove("lightmode"),document.body.classList.add("darkmode")):(document.body.classList.remove("darkmode"),document.body.classList.add("lightmode"))};function applyBackgroundTheme(e){var n="body { background: "+e+"; }",s=document.head||document.getElementsByTagName("head")[0],t=document.createElement("style");return s.appendChild(t),t.type="text/css",t.styleSheet?t.styleSheet.cssText=n:t.appendChild(document.createTextNode(n)),t}const style=applyBackgroundTheme(get_darkmode()?"black":"white");document.addEventListener("DOMContentLoaded",()=>{set_darkmode(),style.parentElement.removeChild(style);const e=document.getElementsByClassName("darkmode-switch")[0];e.onclick=e=>{storage.setItem("darkmode",!get_darkmode()),get_darkmode(),set_darkmode()}})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-175497336-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Building Vaults on Bitcoin"><meta property="og:description" content="This post is syndicated from rubin.io.
Welcome to day 10 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
A &ldquo;Vault&rdquo; is a general concept for a way of protecting Bitcoin from theft through a cold-storage smart contract. While there is not formal definition of what is and is not a Vault, generally a Vault has more structure around a withdrawal than just a multisig."><meta property="og:type" content="article"><meta property="og:url" content="https://judica.org/blog/advent-10/"><meta property="og:image" content="https://judica.org/img/og-img.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-07T00:00:00+00:00"><meta property="og:site_name" content="judica.org -- restore the balance"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://judica.org/img/og-img.png"><meta name=twitter:title content="Building Vaults on Bitcoin"><meta name=twitter:description content="This post is syndicated from rubin.io.
Welcome to day 10 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
A &ldquo;Vault&rdquo; is a general concept for a way of protecting Bitcoin from theft through a cold-storage smart contract. While there is not formal definition of what is and is not a Vault, generally a Vault has more structure around a withdrawal than just a multisig."></head><body><header class=nav><ul><li class=float-left><a href=/>judica.</a></li></ul><ul><li><a href=/about/>about.</a></li><li><a href=/software/>software.</a></li><li><a href=/blog/>blog.</a></li><li><a href=/join/>join.</a></li></ul></header><div class=main2><h1>Building Vaults on Bitcoin</h1><div><h2 class=nobottom>Day 10: Rubin's Bitcoin Advent Calendar</h2></div><small>on December 7, 2021</small><hr></div><div class=main2><div></div><div class=blogtext-inner><p><em>This post is syndicated from <a href=https://rubin.io/advent21>rubin.io</a>.</em></p><p><em>Welcome to day 10 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href=/advent21>here</a> or subscribe at
<a href=https://judica.org/join>judica.org/join</a> to get new posts in your inbox</em></p><p>A &ldquo;Vault&rdquo; is a general concept for a way of protecting Bitcoin from theft
through a cold-storage smart contract. While there is not formal definition of
what is and is not a Vault, generally a Vault has more structure around a
withdrawal than just a multisig.</p><p>One of the earlier
<a href=https://hackingdistributed.com/2016/02/26/how-to-implement-secure-bitcoin-vaults/>references</a>
for Vaults was a design whereby every time you request to withdraw from it you
can &ldquo;reset&rdquo; the request within a time limit. This means that while an attacker
might steal your keys, you can &ldquo;fight&rdquo; to make it a negative sum game &ndash; e.g.,
they&rsquo;ll just keep on paying fees to eventually steal an amount less than they
paid. This might serve to disincentivize hacking exchanges if hackers are less
likely to actually get coins.</p><p>Similar Vaults can be built using Sapio, but the logic for them involves
unrolling the contract a predefined number of steps. This isn&rsquo;t bad because if
the period of timeout is 1 week then just unrolling 5,200 times gets you one
thousand years of hacking disincentive.</p><p>The contract for that might look something like this in Sapio (<em>note: I was
running behind on this post so I may make modifications to make these examples
better later</em>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VaultOne</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Key that will authorize:
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// 1) Recursing with the vault
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// 2) Spending from the vault after not moved for a period
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    key: <span style=color:#a6e22e>bitcoin</span>::PublicKey,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// How long should the vault live for
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    steps: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> VaultOne {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Checks if steps are remaining
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[compile_if]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>not_out_of_steps</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.steps <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            ConditionalCompileType::Never
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            ConditionalCompileType::NoConstraint
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[guard]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>authorize</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        Clause::Key(self.key.clone())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Recurses the vault if authorized
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[then(compile_if = </span><span style=color:#e6db74>&#34;[Self::not_out_of_steps]&#34;</span><span style=color:#75715e>, guarded_by = </span><span style=color:#e6db74>&#34;[Self::authorize]&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> VaultOne {
</span></span><span style=display:flex><span>            key: <span style=color:#a6e22e>self</span>.key.clone(),
</span></span><span style=display:flex><span>            steps: <span style=color:#a6e22e>self</span>.steps <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> amt <span style=color:#f92672>=</span> ctx.funds();
</span></span><span style=display:flex><span>        ctx.template()
</span></span><span style=display:flex><span>            .add_output(amt, <span style=color:#f92672>&amp;</span>next, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For Paying fees via CPFP. Note that we should totally definitely
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// get rid of the dust limit for contracts like this, or enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// IUTXOS with 0 Value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(Amount::from_sat(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>&amp;</span>self.key, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            .into()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Allow spending after a week long delay
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[guard]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>finish</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        Clause::And(vec![
</span></span><span style=display:flex><span>            Clause::Key(self.key.clone()),
</span></span><span style=display:flex><span>            RelTime::try_from(Duration::from_secs(<span style=color:#ae81ff>7</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span>))
</span></span><span style=display:flex><span>                .unwrap()
</span></span><span style=display:flex><span>                .into(),
</span></span><span style=display:flex><span>        ])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Binds the logic to the Contract
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> VaultOne {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {then, Self::step}
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {finish, Self::finish}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But we can also build much more sophisticated Vaults that do more. Suppose we
want to have a vault where once a week you can claim a trickle of bitcoin into a
hot wallet, or you can send it back to a cold storage key. This is a &ldquo;structured
liquidity vault&rdquo; that gives you time-release Bitcoin. Let&rsquo;s check out some code
and talk about it more:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VaultTwo</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Key just for authorizing steps
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    authorize_key: <span style=color:#a6e22e>bitcoin</span>::PublicKey,
</span></span><span style=display:flex><span>    amount_per_step: <span style=color:#a6e22e>bitcoin</span>::Amount,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Hot wallet key
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    hot_key: <span style=color:#a6e22e>bitcoin</span>::PublicKey,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Cold wallet key
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    cold_key: <span style=color:#a6e22e>bitcoin</span>::PublicKey,
</span></span><span style=display:flex><span>    steps: <span style=color:#66d9ef>u32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> VaultTwo {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[compile_if]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>not_out_of_steps</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.steps <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            ConditionalCompileType::Never
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            ConditionalCompileType::NoConstraint
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[guard]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>authorized</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        Clause::Key(self.authorize_key.clone())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[then(compile_if = </span><span style=color:#e6db74>&#34;[Self::not_out_of_steps]&#34;</span><span style=color:#75715e>, guarded_by = </span><span style=color:#e6db74>&#34;[Self::authorized]&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>step</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Creates a recursive vault with one fewer steps
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> next <span style=color:#f92672>=</span> VaultTwo {
</span></span><span style=display:flex><span>            steps: <span style=color:#a6e22e>self</span>.steps <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>self.clone()
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> amt <span style=color:#f92672>=</span> ctx.funds();
</span></span><span style=display:flex><span>        ctx.template()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// send to the new vault
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(amt <span style=color:#f92672>-</span> self.amount_per_step, <span style=color:#f92672>&amp;</span>next, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// withdraw some to hot storage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(self.amount_per_step, <span style=color:#f92672>&amp;</span>self.hot_key, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For Paying fees via CPFP. Note that we should totally definitely
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// get rid of the dust limit for contracts like this, or enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// IUTXOS with 0 Value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(Amount::from_sat(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>&amp;</span>self.authorize_key, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// restrict that we have to wait a week
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .set_sequence(
</span></span><span style=display:flex><span>                <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>                RelTime::try_from(Duration::from_secs(<span style=color:#ae81ff>7</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span>))<span style=color:#f92672>?</span>.into(),
</span></span><span style=display:flex><span>            )<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            .into()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// allow sending the remaining funds into cold storage
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[then(compile_if = </span><span style=color:#e6db74>&#34;[Self::not_out_of_steps]&#34;</span><span style=color:#75715e>, guarded_by = </span><span style=color:#e6db74>&#34;[Self::authorized]&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>terminate</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        ctx.template()
</span></span><span style=display:flex><span>            <span style=color:#75715e>// send the remaining funds to cold storage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(self.amount_per_step<span style=color:#f92672>*</span>self.steps, <span style=color:#f92672>&amp;</span>self.cold_key, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// For Paying fees via CPFP. Note that we should totally definitely
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// get rid of the dust limit for contracts like this, or enable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// IUTXOS with 0 Value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            .add_output(Amount::from_sat(<span style=color:#ae81ff>0</span>), <span style=color:#f92672>&amp;</span>self.authorize_key, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            .into()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> VaultTwo {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {then, Self::step, Self::terminate}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This type of Vault is particularly interesting for e.g., withdrawing from an
exchange business. Imagine a user, Elsa who wants to have a great cold storage
system. So Elsa sets up a xpub key and puts it on ice. She then generates a new
address, and requests that the exchange let the funds go to it. Later that
month, Elsa wants to buy a coffee with her Bitcoin so she has to thaw out her
cold storage to spend (maybe using a offline PSBT signing), and transfer the
funds to her destination or to a hot wallet if she wants a bit of extra pocket
money. Instead suppose Elsa sets up a timerelease vault. Then, she can set up
her cold vault and automatically be able to claim 1 Bitcoin a month out of it,
or if she notices some coins missing from her hot wallet redirect the funds
solely under her ice castle.</p><p>This has many benefits for an average user. One is that you can invest in your
cold storage of keys <em>once</em> in your life and only have to access it in
unexpected circumstance. This means that: users might elect to use something
more secure/inconvenient to access (e.g. strongly geo-sharded); that they won&rsquo;t
reveal access patterns by visiting their key storage facility; and that they
don&rsquo;t need to expose themselves to recurring fat-finger<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> risk.</p><h2 id=getting-a-little-more-advanced>Getting a little more advanced</h2><p>What are some other things we might want to do in a vault? Let&rsquo;s do a quickfire
&ndash; we won&rsquo;t code these here, but you&rsquo;ll see examples of these techniques in
posts to come:</p><h3 id=send-a-percentage-not-a-fixed-amount>Send a percentage, not a fixed amount</h3><p>Let the contract know the intended amount, and then compute the withdrawals as
percentages in the program.</p><h3 id=non-key-destinations>Non-Key Destinations</h3><p>In the examples above, we use keys for hot wallet, cold wallet, and authorizations.</p><p>However, we could very well use other programs! For example, imagine a
time-release vault that goes into a anti-theft locker.</p><h3 id=change-hot-wallet-every-step>Change Hot Wallet Every Step</h3><p>This one is pretty simple &ndash; if you have N steps just provide a list of N
different destinations and use the i-th one as you go!</p><h3 id=topping-up>Topping up:</h3><p>There are advanced techniques that can be used to allow depositing <em>into</em> a
vault after it has been created (i.e., topping up), but that&rsquo;s too advanced to
go into detail today. For those inclined, a small hint: make the &ldquo;top up&rdquo; vault
consume an output from the previous vault, CTV commits to the script so you can
use a salted P2SH out.</p><h2 id=even-more-advanced>Even more advanced</h2><p>What if we want to ensure that after a withdraw funds are re-inserted into the Vault?</p><p>We&rsquo;ll ditch the recursion (for now), and just look at some basic logic. Imagine
a coin is held by a cold storage key, and we want to use Sapio to generate a transaction
that withdraws funds to an address and sends the rest back into cold storage.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>VaultThree</span> {
</span></span><span style=display:flex><span>    key: <span style=color:#a6e22e>bitcoin</span>::PublicKey,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Special struct for passing arguments to a created contract
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Withdrawal</span> {
</span></span><span style=display:flex><span>    Send {
</span></span><span style=display:flex><span>        addr: <span style=color:#a6e22e>bitcoin</span>::Address,
</span></span><span style=display:flex><span>        amount: <span style=color:#a6e22e>bitcoin</span>::Amount,
</span></span><span style=display:flex><span>        fees: <span style=color:#a6e22e>bitcoin</span>::Amount,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    Nothing,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#e6db74>/// required...
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>impl</span> Default <span style=color:#66d9ef>for</span> Withdrawal {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>default</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Withdrawal::Nothing
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> StatefulArgumentsTrait <span style=color:#66d9ef>for</span> Withdrawal {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// helper for rust type system issue
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>default_coerce</span>(
</span></span><span style=display:flex><span>    k: <span style=color:#f92672>&lt;</span>VaultThree <span style=color:#66d9ef>as</span> Contract<span style=color:#f92672>&gt;</span>::StatefulArguments,
</span></span><span style=display:flex><span>) -&gt; Result<span style=color:#f92672>&lt;</span>Withdrawal, CompilationError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    Ok(k)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> VaultThree {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[guard]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>signed</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        Clause::Key(self.key.clone())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[continuation(guarded_by = </span><span style=color:#e6db74>&#34;[Self::signed]&#34;</span><span style=color:#75715e>, coerce_args = </span><span style=color:#e6db74>&#34;default_coerce&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>withdraw</span>(self, ctx: <span style=color:#a6e22e>Context</span>, request: <span style=color:#a6e22e>Withdrawal</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Withdrawal::Send { amount, fees, addr } <span style=color:#f92672>=</span> request {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> amt <span style=color:#f92672>=</span> ctx.funds();
</span></span><span style=display:flex><span>            ctx.template()
</span></span><span style=display:flex><span>                <span style=color:#75715e>// send the rest recursively to this contract
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .add_output(amt <span style=color:#f92672>-</span> amount <span style=color:#f92672>-</span> fees, self, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// process the withdrawal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .add_output(amount, <span style=color:#f92672>&amp;</span>Compiled::from_address(addr, None), None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// mark fees as spent
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                .spend_amount(fees)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                .into()
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            empty()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> VaultThree {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span> {updatable<span style=color:#f92672>&lt;</span>Withdrawal<span style=color:#f92672>&gt;</span>, Self::withdraw}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we&rsquo;ve seen how updatable continuation clauses can be used to dynamically
pass arguments to a Sapio contract and let the module figure out what the next
transactions should be, managing recursive and non-enumerated state transitions
(albeit with a trust model).</p><p>That&rsquo;s probably enough for today, before I make your head explode. We&rsquo;ll see more examples soon!</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Sending the wrong amount because you click the wrong key with your too-large hands.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div></div></div><hr><div class=main2><div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//judica-org.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div></div></div><hr><footer style=text-align:center;bottom:0;padding-bottom:10px;width:100%>&copy; Judica, Inc 2022 | contact@judica.org | <a class=darkmode-switch>dark/light theme</a> | <a target=_blank href=https://discord.gg/WfBjavZpmM>discord</a></footer></body></html>