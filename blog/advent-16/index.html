<!doctype html><html><head><meta name=viewport content="width=device-width,initial-scale=1"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@200;500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;600&display=swap" rel=stylesheet><link rel=stylesheet type=text/css href=/css/style.css><script>const storage=window.localStorage,get_darkmode=()=>{const e=storage.getItem("darkmode");return e==null||e==="true"},set_darkmode=()=>{get_darkmode()?(document.body.classList.remove("lightmode"),document.body.classList.add("darkmode")):(document.body.classList.remove("darkmode"),document.body.classList.add("lightmode"))};function applyBackgroundTheme(e){var n="body { background: "+e+"; }",s=document.head||document.getElementsByTagName("head")[0],t=document.createElement("style");return s.appendChild(t),t.type="text/css",t.styleSheet?t.styleSheet.cssText=n:t.appendChild(document.createTextNode(n)),t}const style=applyBackgroundTheme(get_darkmode()?"black":"white");document.addEventListener("DOMContentLoaded",()=>{set_darkmode(),style.parentElement.removeChild(style);const e=document.getElementsByClassName("darkmode-switch")[0];e.onclick=e=>{storage.setItem("darkmode",!get_darkmode()),get_darkmode(),set_darkmode()}})</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-175497336-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="Composability in Sapio Contracts"><meta property="og:description" content="This post is syndicated from rubin.io.
Welcome to day 16 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
Who here has some ERC-20s or 721s1? Anyone? No one? Whatever.
The Punchline is that a lotta fuss goes into Ethereum smart contracts being Turing Complete but guess what? Neither ERC-20 nor 721 really have anything to do with being Turing Complete."><meta property="og:type" content="article"><meta property="og:url" content="https://judica.org/blog/advent-16/"><meta property="og:image" content="https://judica.org/img/og-img.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-13T00:00:00+00:00"><meta property="og:site_name" content="judica.org -- restore the balance"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://judica.org/img/og-img.png"><meta name=twitter:title content="Composability in Sapio Contracts"><meta name=twitter:description content="This post is syndicated from rubin.io.
Welcome to day 16 of my Bitcoin Advent Calendar. You can see an index of all the posts here or subscribe at judica.org/join to get new posts in your inbox
Who here has some ERC-20s or 721s1? Anyone? No one? Whatever.
The Punchline is that a lotta fuss goes into Ethereum smart contracts being Turing Complete but guess what? Neither ERC-20 nor 721 really have anything to do with being Turing Complete."></head><body><header class=nav><ul><li class=float-left><a href=/>judica.</a></li></ul><ul><li><a href=/about/>about.</a></li><li><a href=/software/>software.</a></li><li><a href=/blog/>blog.</a></li><li><a href=/join/>join.</a></li></ul></header><div class=main2><h1>Composability in Sapio Contracts</h1><div><h2 class=nobottom>Day 16: Rubin's Bitcoin Advent Calendar</h2></div><small>on December 13, 2021</small><hr></div><div class=main2><div></div><div class=blogtext-inner><p><em>This post is syndicated from <a href=https://rubin.io/advent21>rubin.io</a>.</em></p><p><em>Welcome to day 16 of my Bitcoin Advent Calendar. You can see an index of all
the posts <a href=/advent21>here</a> or subscribe at
<a href=https://judica.org/join>judica.org/join</a> to get new posts in your inbox</em></p><p>Who here has some ERC-20s or 721s<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>? Anyone? No one? Whatever.</p><p>The Punchline is that a lotta fuss goes into Ethereum smart contracts being
Turing Complete but guess what? Neither ERC-20 nor 721 really have anything to
do with being Turing Complete. What they do have to do with is having a
tightly defined interface that can integrate into other applications nicely.</p><p>This is great news for Bitcoin. It means that a lot of the cool stuff happening
in eth-land isn&rsquo;t really about Turing Completeness, it&rsquo;s about just defining
really kickass interfaces for the things we&rsquo;re trying to do.</p><p>In the last few posts, we already saw examples of composability. We took a bunch
of concepts and were able to nest them inside of each other to make
Decentralized Coordination Free Mining Pools. But we can do a lot more with
composability than just compose ideas togehter by hand. In this post I&rsquo;ll give
you a little sampler of different types of programmatic composability and interfaces,
like the ERC-20 and 721.</p><h2 id=address-composability>Address Composability</h2><p>Because many Sapio contracts can be made completely noninteractively (with CTV
or an Oracle you&rsquo;ll trust to be online later), if you compile a Sapio contract
and get an address you can just plug it in somewhere and it &ldquo;composes&rdquo; and you
can link it later. We saw this earlier with the ability to make a channel
address and send it to an exchange.</p><p>However, for Sapio if you just do an Address it won&rsquo;t necessarily have the
understanding of what that address is for so you won&rsquo;t get any of the Sapio
&ldquo;rich&rdquo; features.</p><h3 id=pre-compiled>Pre-Compiled</h3><p>You can also take not just an address, but an entire (json-serialized?) Compiled
object that would include all the relevant metadata.</p><h2 id=rust-generic-types-composability>Rust Generic Types Composability</h2><p>Well, if you&rsquo;re a rust programmer this basically boils down to rust types rule!
We&rsquo;ll give a couple examples.</p><p>The simplest example is just composing directly in a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[then]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>some_function</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>    ctx.template()
</span></span><span style=display:flex><span>        .add_output(ctx.funds(), <span style=color:#f92672>&amp;</span>SomeOtherContract{<span style=color:#75715e>/**/</span>}, None)<span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>        .into()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What if we want to pass any Contract as an argument for a Contract? Simple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span> {
</span></span><span style=display:flex><span>    a : Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Contract<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What if we want to restrict it a little bit more? We can use a trait bound.
Now only Y (or anything implementing GoodContract) can be plugged in.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>trait</span> GoodContract : <span style=color:#a6e22e>Contract</span> {
</span></span><span style=display:flex><span>    decl_then<span style=color:#f92672>!</span>{some_thing}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Y</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> GoodContract <span style=color:#66d9ef>for</span> Y {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[then]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>some_thing</span>(self, ctx: <span style=color:#a6e22e>Context</span>) {
</span></span><span style=display:flex><span>        empty()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Contract <span style=color:#66d9ef>for</span> Y {
</span></span><span style=display:flex><span>    declare<span style=color:#f92672>!</span>{then, Self::some_thing}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>GoodContract</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    a : Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> GoodContract<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// note the inner type of a and b don&#39;t have to match
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    b : Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> GoodContract<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Boxing gives us some power to be Generic at runtime, but we can also do some
more &ldquo;compile time&rdquo; logic. This can have some advantages, e.g., if we want to
guarantee that types are the same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span><span style=color:#f92672>&lt;</span>T : <span style=color:#a6e22e>Contract</span>, U: <span style=color:#a6e22e>GoodContract</span><span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    a : <span style=color:#a6e22e>T</span>, 
</span></span><span style=display:flex><span>    b : <span style=color:#a6e22e>T</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a more specific concrete type -- could be a T even
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    c: <span style=color:#a6e22e>U</span>,
</span></span><span style=display:flex><span>    d: <span style=color:#a6e22e>U</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sometimes it can be helpful to wrap things in functions, like we saw in the Vaults post.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>X</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>Contract</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This lets us stub in whatever we want for a function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    a : Box<span style=color:#f92672>&lt;</span>Fn(Self, Context) -&gt; <span style=color:#a6e22e>TxTmplIt</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this lets us get back any contract
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    b : Box<span style=color:#f92672>&lt;</span>Fn(Self, Context) -&gt; Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> Contract<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this lets us get back a specific contract
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    c : Box<span style=color:#f92672>&lt;</span>Fn(Self, Context) -&gt; <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Clearly there&rsquo;s a lot to do with the rust type system and making components.</p><p>It would even be possible to make certain types of &lsquo;unchecked&rsquo; type traits,
for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>trait</span> Reusable {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AlsoReusable</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    a: <span style=color:#a6e22e>T</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Only reusable if T Reusable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Reusable <span style=color:#66d9ef>for</span> AlsoReusable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>where</span> T: <span style=color:#a6e22e>Reusable</span> {}
</span></span></code></pre></div><p>The <code>Reusable</code> tag could be used to tag contract components that would be &ldquo;reuse
safe&rdquo;. E.g., an HTLC or HTLC containing component would not be reuse safe since
hashes could be revealed. While reusability isn&rsquo;t &ldquo;proven&rdquo; &ndash; that&rsquo;s up to the
author to check &ndash; these types of traits can help us reason about the properties
of compositions of programs more safely. Unfortunately, Rust lacks negative
trait bounds (i.e., Not-Reusable), so you can&rsquo;t reason about certain types of things.</p><h3 id=inheritence>Inheritence</h3><p>We don&rsquo;t have a fantastic way to do inheritence in Sapio presently. But stay
tuned! For now, then best you get is that you can do traits (like
<code>GoodContract</code>).</p><h2 id=cross-module-composability--wasm>Cross Module Composability & WASM</h2><p>One of the goals of Sapio is to be able to create contract modules with a
well-defined API Boundary that communicates with JSONs and is &ldquo;typed&rdquo; with
JSONSchema. This means that the Sapio modules can be running anywhere (e.g., a
remote server) and we can treat it like any other component.</p><p>Another goal of Sapio is to make it possible to compile modules into standalone
WASM modules. WASM stands for Web Assembly, it&rsquo;s basically a small deterministic
computer emulator program format so we can compile our programs and run them
anywhere that the WASM interpreter is available.</p><p>Combining these two goals, it&rsquo;s possible for one Sapio program to dynamically
load another as a WASM module. This means we can come up with a component,
compile it, and then link to it later from somewhere else. For example, we could
have a Payment Pool where we make each person&rsquo;s leaf node a WASM module of their
choice, that could be something like a Channel, a Vault, or anything that
satisfies a &ldquo;Payment Pool Payout Interface&rdquo;.</p><p>For example, suppose we wanted to a generic API for making a batched
payment.</p><h3 id=defining-the-interface>Defining the Interface</h3><p>First, we define a payment that we want to batch.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// A payment to a specific address
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Payment</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Amount (btc)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// The amount to send
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> amount: <span style=color:#a6e22e>AmountF64</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Address
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// The Address to send to
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> address: <span style=color:#a6e22e>bitcoin</span>::Address,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we define the full API that we want. <em>Naming and versioning is still a
something we need to work on in the Sapio ecosystem, but for now it makes sense
to be verbose and include a version.</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BatchingTraitVersion0_1_1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> payments: Vec<span style=color:#f92672>&lt;</span>Payment<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Feerate (Bitcoin per byte)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> feerate_per_byte: <span style=color:#a6e22e>AmountF64</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Lastly, to finish defining the API, we have to do something really gross looking
in order to make it automatically checkable &ndash; this is essentially this is what the
user defined <code>BatchingTraitVersion0_1_1</code> is going to verify modules are able to
understand. This is going to be improved in Sapio over time for better typechecking!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> SapioJSONTrait <span style=color:#66d9ef>for</span> BatchingTraitVersion0_1_1 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_example_for_api_checking</span>() -&gt; <span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>#[derive(Serialize)]</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Versions</span> {
</span></span><span style=display:flex><span>            BatchingTraitVersion0_1_1(BatchingTraitVersion0_1_1),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        serde_json::to_value(Versions::BatchingTraitVersion0_1_1(
</span></span><span style=display:flex><span>            BatchingTraitVersion0_1_1 {
</span></span><span style=display:flex><span>                payments: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[],
</span></span><span style=display:flex><span>                feerate_per_byte: <span style=color:#a6e22e>Amount</span>::from_sat(<span style=color:#ae81ff>0</span>).into(),
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        ))
</span></span><span style=display:flex><span>        .unwrap()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=implementing-the-interface>Implementing the Interface</h3><p>Let&rsquo;s say that we want to make a contract like <code>TreePay</code> implement
<code>BatchingTraitVersion0_1_1</code>. What do we need to do?</p><p>First, let&rsquo;s get the boring stuff out of the way, we need to make the <code>TreePay</code>
module understand that it should support <code>BatchingTraitVersion0_1_1</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// # Different Calling Conventions to create a Treepay
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Versions</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Standard Tree Pay
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    TreePay(TreePay),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Batching Trait API
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    BatchingTraitVersion0_1_1(BatchingTraitVersion0_1_1),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>REGISTER<span style=color:#f92672>!</span>[[TreePay, Versions], <span style=color:#e6db74>&#34;logo.png&#34;</span>];
</span></span></code></pre></div><p>Next, we just need to define logic converting the data provided in
<code>BatchingTraitVersion0_1_1</code> into a <code>TreePay</code>. Since <code>BatchingTraitVersion0_1_1</code>
is really basic, we need to pick values for the other fields.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>BatchingTraitVersion0_1_1<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> TreePay {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(args: <span style=color:#a6e22e>BatchingTraitVersion0_1_1</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        TreePay {
</span></span><span style=display:flex><span>            participants: <span style=color:#a6e22e>args</span>.payments,
</span></span><span style=display:flex><span>            radix: <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>            <span style=color:#75715e>// estimate fees to be 4 outputs and 1 input + change
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            fee_sats_per_tx: <span style=color:#a6e22e>args</span>.feerate_per_byte <span style=color:#f92672>*</span> ((<span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>41</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>41</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>),
</span></span><span style=display:flex><span>            timelock_backpressure: None,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>Versions<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> TreePay {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(v: <span style=color:#a6e22e>Versions</span>) -&gt; <span style=color:#a6e22e>TreePay</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> v {
</span></span><span style=display:flex><span>            Versions::TreePay(v) <span style=color:#f92672>=&gt;</span> v,
</span></span><span style=display:flex><span>            Versions::BatchingTraitVersion0_1_1(v) <span style=color:#f92672>=&gt;</span> v.into(),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=using-the-interface>Using the Interface</h3><p>To use this <code>BatchingTraitVersion0_1_1</code>, we can just define a struct as follows,
and when we deserialize it will be automatically verified to have declared a
fitting API.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RequiresABatch</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// # Which Plugin to Use
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// Specify which contract plugin to call out to.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    handle: <span style=color:#a6e22e>SapioHostAPI</span><span style=color:#f92672>&lt;</span>BatchingTraitVersion0_1_1<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>SapioHostAPI</code> handle can be either a human readable name (like
&ldquo;user_preferences.batching&rdquo; or &ldquo;org.judica.modules.batchpay.latest&rdquo;) and looked
up locally, or it could be an exact hash of the specific module to use.</p><p>We can then use the handle to resolve and compile against the third party module.
Because the module lives in an entirely separate WASM execution context,
we don&rsquo;t need to worry about it corrupting our module or being able to access
information we don&rsquo;t provide it.</p><h1 id=call-to-action>Call to Action</h1><p><strong>ARE YOU A BIG BRAIN PROGRAMMING LANGUAGE PERSON?</strong></p><p><strong>PLEASE <a href=https://judica.org/join>HELP ME</a> MAKE THIS SAPIO
HAVE A COOL AND USEFUL TYPE SYSTEM I AM A SMALL BRAIN BOI AND THIS STUFF IS
HARD AND I NEED FRENZ.</strong></p><p><strong>EVEN THE KIND OF &ldquo;FRENZ&rdquo; THAT YOU HAVE TO PAY FOR <em>wink</em>.</strong></p><p><strong><a href=https://judica.org/join>CLICK HERE</a></strong></p><p>In the posts coming Soonâ„¢, we&rsquo;ll see some more specific examples of contracts
that make heavier use of having interfaces and all the cool shit we can get done.</p><h1 id=thats-all-i-have-to-say-see-you-tomorrow>That&rsquo;s all I have to say. See you tomorrow.</h1><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>if you&rsquo;ve been living under a big rock, ICO tokens and NFTs.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div></div></div><hr><div class=main2><div></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//judica-org.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div></div></div><hr><footer style=text-align:center;bottom:0;padding-bottom:10px;width:100%>&copy; Judica, Inc 2022 | contact@judica.org | <a class=darkmode-switch>dark/light theme</a></footer></body></html>